#include <DHT.h>
#include <DHT_U.h>

#include <Wire.h> //Biblioteca utilizada gerenciar a comunicação entre dispositicos através do protocolo I2C
#include <LiquidCrystal_I2C.h> //Biblioteca controlar display 16x2 através do I2C

#include <avr/io.h>
#include <avr/interrupt.h>

#include <PID_v1.h>

//#define pin_input A1 //(float t = dht.readTemperature())
//#define pin_set A2 //(sinal)
//#define Pin_out 3 //defineIntensidade(output)

#define PINO_ZC 2    // recomendo não mudar este pino
#define PINO_DIM 3   // recomendo não mudar este pino

#define PULSO 4    // tempo em que o pino DIM ficara em HIGH, contado em ciclos do Timer1
#define FRACO 60   // intensidade minima desejada para a lampada (0 a ~520) 
#define FORTE 485  // intensidade maxima desejada para a lampada (0 a ~520) 

#define col  16 //Define o número de colunas do display utilizado
#define lin   2 //Define o número de linhas do display utilizado
#define ende  0x27 //Define o endereço do display
#define DHTPIN A1 // pino que estamos conectado
#define DHTTYPE DHT11 // DHT 11
#define pinopotenc A2

DHT dht(DHTPIN, DHTTYPE);

int buttonPin = 8;//Define buttonPin no pino digital 8

bool ligado=false;

LiquidCrystal_I2C lcd(ende, col, lin); //Cria o objeto lcd passando como parâmetros o endereço, o nº de colunas e o nº de linhas;

unsigned long lastSend=0;

double Setpoint, Input, Output;

double kp=2, ki=1.2 , kd=1;

PID myPID(&Input, &Output, &Setpoint,kp,ki,kd,DIRECT);
 
void setup() 
{
  dht.begin();
  pinMode(pinopotenc, INPUT);
  pinMode(buttonPin , INPUT);
  lcd.init(); //Inicializa a comunicação com o display já conectado
  lcd.clear(); //Limpa a tela do display
  lcd.backlight(); //Aciona a luz de fundo do display

  pinMode(PINO_ZC, INPUT_PULLUP);
  pinMode(PINO_DIM, OUTPUT);

  Serial.begin(115200);
  Input= int(dht.readTemperature()); 
  Setpoint=int((analogRead(pinopotenc)/34.1)+25);
  myPID.SetMode(AUTOMATIC);

  // ativa o Timer/Counter1 com os modos dos bits 0 e 1, ou seja,
  // ativa Comparador A e detector de overflow
  TIMSK1 = 0x03;    // 16.11.8 na datasheet 

  // desabilita inicialmente o timer:
  TCCR1A = 0x00;    // 16.11.1 na datasheet   
  TCCR1B = 0x00;    // 16.11.2 na datasheet
  
}

void defineIntensidade(int k) { 
  // recebe um valor de 0 a 1024 para a intensidade da lampada, e define o valor correspondente
  // (entre as constantes FORTE e FRACO) para o comparador do Timer1
  OCR1A=map(k,0,1024,FORTE,FRACO);  // 16.11.5 na datasheet 
}

void zeroCross() { // chamada automaticamente sempre que o pino 2 mudar para HIGH  
  TCCR1B=0x04; // 16.11.2 - habilita o timer no modo que divide o clock real por 256
  TCNT1=0;     // 16.11.4 - zera o contador do timer
  
  // a partir daqui, esta interrupcao encerra (ate a proxima repeticao do ciclo AC), 
  // mas o ATmega vai começar a incrementar o valor de TCNT1 automaticamente a cada 
  // ciclo do Timer1, provocando uma nova interrupcao (TIMER1_COMPA) quando o contador 
  // alcancar o valor definido em OCR1A.
  // Assim, se OCR1A for um valor alto, vai demorar mais para a interrupcao acontecer, 
  // e vice-versa. Essa demora corresponde ao tempo em que a lampada fica apagada.
}

ISR(TIMER1_COMPA_vect) { // chamada automaticamente sempre que o TCNT1 alcanca OCR1A.
  // manda um valor HIGH para o pino DIM, acendendo a lampada
  digitalWrite(PINO_DIM,HIGH);  
  // inicia um novo contador para o Timer1, calculado para provocar um overflow (e 
  // uma nova interrupcao - TIMER1_OVF) apos o numero de ciclos definido em PULSO.
  TCNT1 = 65536-PULSO;
  
  // a partir daqui, esta interrupcao encerra, e o ATmega comeca a incrementar o 
  // valor de TCNT1 automaticamente a cada ciclo do Timer1, provocando uma nova 
  // interrupcao (OVF) quando o contador entrar em overflow. Como o contador TCNT1
  // tem 16 bits, o overflow acontece quando ele ultrapassa o valor de 65535.
}

ISR(TIMER1_OVF_vect) { // chamada automaticamente sempre que ha overflow de TCNT1.
  // manda um valor LOW para o pino DIM, voltando a apagar a lampada
  digitalWrite(PINO_DIM,LOW);
  // desativa o timer que foi inicialmente ativado pela nossa funcao zeroCross().
  TCCR1B = 0x00;    
  
  // a partir daqui, esta interrupcao encerra. O normal eh que a proxima 
  // interrupcao a acontecer seja a do pino 2 (zeroCross()), no proximo 
  // meio ciclo AC.      
}

 
void loop() 
{
  
  int sinal;
  sinal=int((analogRead(pinopotenc)/34.1)+25);
  
  while(ligado!=true){
    sinal=(analogRead(pinopotenc)/33.08)+25;
    lcd.setCursor(0, 0); //Coloca o cursor do display na coluna 1 e linha 1
    lcd.print("Inserir a Temp:");
    lcd.setCursor(6, 1); //Coloca o cursor do display na coluna 1 e linha 1      for(int posi_LCD = 0; posi_LCD < 36; posi_LCD ++)
    lcd.print(String(sinal)+"C");
    
    if (digitalRead(buttonPin)==1){
      delay(1000);
      ligado=true;
      lcd.clear();
    }  
  }
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  // testa se retorno é valido, caso contrário algo está errado.

    lcd.setCursor(0, 0); //Coloca o cursor do display na coluna 1 e linha 1
    lcd.print("Temp: " + String(t) + "C");//Exibe a mensagem na primeira linha do display
    lcd.setCursor(0, 1); //Coloca o cursor do display na coluna 1 e linha 2
    lcd.print("Um:");  //Exibe a mensagem na segunda linha do display
    lcd.print(h);
    lcd.setCursor(5,1);
    lcd.print(" | ");
    lcd.setCursor(8,1);
    lcd.print("Meta:"+String(sinal)+"C");

    attachInterrupt(0,zeroCross, RISING);

    Input= int(dht.readTemperature()); 
    Setpoint=int(sinal);
    myPID.Compute();
    Output=Output+50;

    if(int(sinal)>int(t)+4){
      defineIntensidade(500);
    }
    else{
      defineIntensidade(Output);
    }
    

    if(millis()-lastSend >100){
    lastSend=millis();

    Serial.print(Setpoint);
    Serial.print("  -  ");
    Serial.print(Input);
    Serial.print("  -  ");
    Serial.print(Output);
    Serial.println("");
  }

        if (digitalRead(buttonPin)==1){
      ligado=false;
      detachInterrupt(0);
      defineIntensidade(0);
      lcd.clear();
    }  

  delay(500); //INTERVALO DE 2 SEGUNDOS
}
